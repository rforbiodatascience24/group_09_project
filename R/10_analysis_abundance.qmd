---
format: 
  html:
    self-contained: true
---
# Analysis of species abundances

```{r}
library("tidyverse")
library("here")
library("broom")
library("vegan")
source("99_proj_func.R")
```


```{r}
data_path <- here("data/06_dat_augmented.csv")
dataset <- read_csv(data_path,
                    na = c("nd", "-", "na"),
                    show_col_types = FALSE)
```

### Assessing relationships between species abundance and metadata features

Let's analyze the diversity between glucose tolerances and BMI groups.

We do this by calculating a distance matrix based on the microbial abundance data, which then can be used to visualize the differences in composition in a reduced dimensionality.

```{r}
# Pull the class labels for glucose tolerance
glucose_tolerance_labels <- dataset |> 
  pull(glucose_tolerance)
# and BMI
BMI_labels <- dataset |> 
  pull(BMI_class)

# Select abundance data from data set to calculate distances
abundance_data <- dataset |> 
  select(matches("^s_"))

# Calculate Beta diversity based on Bray-Curtis distance
bc_dist <- vegdist(abundance_data, method = "bray")

# Perform PCoA
pcoa_result <- cmdscale(as.dist(bc_dist), k = 2, eig = TRUE)

# Extract eigenvalues and calculate proportion of variance explained
eigenvalues <- pcoa_result |>  pluck("eig")
variance_explained <- eigenvalues / sum(eigenvalues)

# Combine PCoA results with group labels 
pcoa_df <- pcoa_result |> 
  pluck("points") |> 
  as.data.frame() |>  
  rename(PCoA1 = V1, PCoA2 = V2) |> 
  mutate(glucose_tolerance = glucose_tolerance_labels) |> 
  mutate(BMI_class = BMI_labels)
```

```{r}
pcoa_glucose_tolerance <- ggplot(pcoa_df, aes(x = PCoA1, y = PCoA2, color = glucose_tolerance_labels)) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "PCoA of health classes on microbiome composition",
       x = paste0("PCoA1 (", round(variance_explained |>  first() * 100, 2), "%)"),
       y = paste0("PCoA2 (", round(variance_explained |>  nth(2) * 100, 2), "%)"),
       color = "Glucose tolerance")

save_plot_custom(
  plot = pcoa_glucose_tolerance,
  filename = "10_pcoa_glucose_tolerance.jpg"
)
pcoa_glucose_tolerance
```

```{r}
pcoa_bmi <- ggplot(pcoa_df, aes(x = PCoA1, y = PCoA2, color = BMI_labels)) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "PCoA of bmi classes on microbiome composition",
       x = paste0("PCoA1 (", round(variance_explained |>  first() * 100, 2), "%)"),
       y = paste0("PCoA2 (", round(variance_explained |>  nth(2) * 100, 2), "%)"),
       color = "BMI class")

save_plot_custom(
  plot = pcoa_bmi,
  filename = "10_pcoa_bmi.jpg"
)
pcoa_bmi
```

The plots show that the samples do not cluster in any significant way, either for the BMI or for the glucose tolerance, this is in agreement with the observation made so far.

We perform a PERMANOVA test to quantify the difference between the BMI groups, testing the following:

-   Null hypothesis : There is no difference in microbial community across composition across the BMI classes
-   Alternative hypothesis: There is a difference in microbial community composition across BMI classes.

```{r}
# PERMANOVA to   see whether the diversity of microbial communities differ across bmi
anova_result_bmi <- adonis2(bc_dist ~ BMI_class,
                         data = dataset)
print(anova_result_bmi)
```

The results of the PERMANOVA agree with what is seen in the PCoA as the P.value is 0.208, which indicates that the differences in microbial composition across BMI classes is not significant. Also R2=0.0238 means that bmi contributes to only 2.38% of the variance in the diversity of microbial community across the bmi classes.

### Statistical analysis of samples microbiota

Before we can study how the bacterial species may be related to type 2 diabetes, we need to find which bacteria have more than 50 values that are not 0. Even though 0 is a meaningful value in the dataset, we need some data points to vary in order to see if there is a meaning full relationship.

```{r}
#Get a list of the bacteria that have less than n samples where the value is different from 0
n <- 50
sparse_columns <- dataset |>  
  select(starts_with("s_")) |> 
  pivot_longer(cols = starts_with("s_"),
               names_to = "backteria",
               values_to = "abundance") |> 
  filter(abundance > 0) |> 
  group_by(backteria) |> 
  summarise(non_zero_samples = n()) |> 
  filter(non_zero_samples < n) |> 
  pull(backteria)
```

```{r}
#splitting dataset into metadata and bacteria data 
metadata <- dataset |> 
  select(-starts_with("s_")) 
```

We will perform the p-value analysis where we compare the bacterial samples from normal and T2D (type 2 diabetes) patients. Therefore, we will remove the impaired samples and sparse data. Next, we will transform the columns and convert the data from wide format to long format to conduct the p-value analysis.

```{r}
dataset_long <- dataset |> 
  filter(glucose_tolerance != "impaired" ) |> 
  select(-all_of(sparse_columns)) |> 
  pivot_longer(cols = starts_with("s_"),
               names_to = "backteria",
               values_to = "abundance")
```

Then we group the data by bacteria and nest it. After that, we ungroup it. By doing so, we obtain another tibble, which is a table for each bacterium.

```{r}
dataset_long_nested <- dataset_long|> 
  group_by(backteria) |> 
  nest() |> 
  ungroup()

dataset_long_nested
```

Here we see how the data can be pulled out for a choosen bacterium.

```{r}
#How to get the data
dataset_long_nested |> 
  filter(backteria == "s_Bacteroides_caccae") |> 
  pull(data)
```

Then we fit a linear fitting model to each bacterium.

```{r}
dataset_long_nested <- dataset_long_nested |> 
  group_by(backteria) |> 
  mutate(model_object = map(.x = data,
                            .f = ~lm(formula = abundance ~ is_diseased,
                                     data = .x))) |> 
  mutate(model_object_tidy = map(.x = model_object,
                                 .f = ~tidy(x = .x,
                                            conf.int = TRUE,
                                            conf.level = 0.95)))
```

Then we show how a linear model for a random bacterium would look.

```{r}
#How to get the model
dataset_long_nested |> 
  filter(backteria == "s_Bacteroides_caccae") |> 
  pull(model_object_tidy)
```

We unnest the model object so we can access the data and values inside the model.

```{r}
dataset_estimates <- dataset_long_nested |> 
  unnest(model_object_tidy)
dataset_estimates
```

Then we check if there are any bacteria that are significant at the alpha = 0.05 level. We filter for those, and we find that none of the bacteria are significant at that level.

```{r}
dataset_estimates1 <- dataset_estimates |> 
  filter(term == "is_diseased") |> 
  select(backteria,p.value,estimate,conf.low,conf.high,p.value) |> 
  ungroup() |> 
  mutate(q.value = p.adjust(p.value),
         is_significant = case_when(q.value <= 0.05 ~ "yes",
                                    q.value > 0.05 ~ "no"))
dataset_estimates1 |> 
  filter(is_significant == "yes")
```

```{r}
# clean environment
# rm(list = ls() |>  
#       keep(~ !is.function(get(.))) |>  
#       discard(~ . %in% ls()))
```
