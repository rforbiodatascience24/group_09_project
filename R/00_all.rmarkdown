---
title: "Changes in microbiota of type 2 diabetes patients"
author: 
  - "Anita Skovbjerg Hjort-Gregersen (s201190)"
  - "Asiya Mohamad Yusuf Muse (s243930)"
  - "Magnus Harthimmer (s233426)"  
  - "Marco Andreis (s243116)"
  - "Rebecca Hjermind Millum (s215024)"

execute:
  warning: false
  message: false

toc: true
format: 
  html:
    self-contained: true
editor: visual
---


### Setup

Load packages necessary for the project.


```{r}
# general libraries
library("quarto")
library("tidyverse")
library("here")

# for data collection
library('httr')
library('jsonlite')

# for visualization / plotting
library("ggridges")
library("patchwork")
library("viridis")

# for analysis
library("table1")
library("broom")
library("vegan")

# Import custom function
source("99_proj_func.R")
```


For the project output we need three folders (\_raw, data, results). This file creates those folders if they are not already present and then proceed to run the whole project.


```{r}
# folder to store the raw dataset before any processing
target_dir <- "../_raw/"
if (!file.exists(target_dir)) {
  dir.create(target_dir, recursive = TRUE)
}

# folder to store the intermediate processed dataset
target_dir <- "../data/"
if (!file.exists(target_dir)) {
  dir.create(target_dir, recursive = TRUE)
  }

# folder to store the results of the analysis (html and plots)
target_dir <- "../results/"
if (!file.exists(target_dir)) {
  dir.create(target_dir, recursive = TRUE)
  }
```
---
format: 
  html:
    self-contained: true
---
# Retrieve original data

```{r}
library("tidyverse")
library('httr')
library('jsonlite')
```


This first thing to do is acquire the dataset which is available on [kaggle](https://www.kaggle.com/api/v1/datasets/download/antaresnyc/human-metagenomics). We check if the dataset is already present, if it is not, we collect it programmatically from kaggle and save it in the \_raw folder.

```{r}
target_dir <- "../_raw/"
wanted_file <- "abundance.csv"
  
# check if the file is already present 
already_present <- file.exists(str_c(target_dir, wanted_file))

if (already_present) {
  message(str_c("The dataset file is already present. Check ", target_dir))
} else {
  # Define the Kaggle dataset path and download location
  dataset_slug <- "antaresnyc/human-metagenomics"
  output_file <- "../_raw/human_metagenomics.zip"
  
  # Dowload the dataset from kaggle
  response <- GET(
    url = str_c("https://www.kaggle.com/api/v1/datasets/download/", dataset_slug),
    write_disk(output_file)
  )
  
  # Unzip the downloaded file
  unzip(output_file, exdir = target_dir)
  
  # Get list of files in the directory 
  extracted_files <- list.files(target_dir, recursive = TRUE)

  # Delete files we don't care about
  files_to_delete <- setdiff(extracted_files, wanted_file)
  map(files_to_delete, ~ {
    file_path <- file.path(target_dir, .x)
      file.remove(file_path)})
}
```

---
format: 
  html:
    self-contained: true
---

# Create a copy of the raw dataset for analysis

```{r}
library("tidyverse")
library("here")
```


Having the dataset we now verify that it can be loaded without problems, after doing so we create a copy of it in the data folder (the \_raw should be left alone not touched by anyone).

```{r}
# verify that the dataset can be loaded successfully
data_path <- "../_raw/abundance.csv"
dataset <- read_csv(data_path, show_col_types = FALSE)
```

We immediately get parsing errors...

(NOTE: this was really inconsistent and refreshing the page or restarting the R session was sometimes enough to change the behavior).

```{r}
problems(dataset)
```

We can see that they are due to some cells having the a different value type from the expected. We will firstly perform data selection and cleaning, if the issues persist we will handle them later.

```{r}
# show a couple of rows from the dataset just to be sure
head(dataset)
```

```{r}
target_dir <- "../data"
# save the dataset in the data fodler
write_csv(dataset, str_c(target_dir, "/02_dat_load.csv"))
```

# Is the dataset what we expect from the original paper?

```{r}
library("tidyverse")
library("here")
```

### The history of the dataset

To do a efficient cleaning we need to understand the format of our data and what it represents, so let's investigate the dataset origins.

The [original paper](https://doi.org/10.1371/journal.pcbi.1004977) is interested in comparing the microbial populations of patients both healthy and affected by various diseases with the aim of discovering disease biomarkers and predicting health conditions. To do so, they collected the data, which are the results of shot-gun genome sequencing of the samples, from 8 different metagenomics studies (the only one savailable at the time of the study - 2016), which cover: liver cirrhosis, colorectal cancer, inflammatory bowel disease, obesity and Type 2 diabetes and healthy patients. Segata et. al declared a total of 2571 samples before their preprocessing and 2424 after.

The sequencing data was analysed with a software called MetaPhlAn2 which outputs the species-level relative abundances and presence of strain-specific markers. Based on these Segata et. al. performed machine learning studies which are outside of the scope of this project. As we have no functional way of opening the output of MetaPhlAn2, we cannot consult this data.

In 2020 a group of people (outside the SegataLab) transposed the dataset into CSV and published it on kaggle, which is where we found it.

```{r}
data_path <- here("data/02_dat_load.csv")
dataset <- read_csv(data_path, show_col_types = FALSE)
```

```{r}
dim(dataset)
dataset |> 
  distinct() |> 
  dim()
```

Starting really really simple... the dataset has 3610 rows / samples and 3513 features. We immediately see that the number of samples is larger (by 1039) that the 2571 declared in the paper.

We can see that all rows are different, so where do these additional samples come from?

```{r}
dataset |> 
  group_by(dataset_name) |> 
  summarise(n_samples = n())
```

We can trace some of these datasets to the ones mentioned in the paper, but for some this is not so easy.

The following is the paragraph of the paper were the data used is described:

"We initially considered a total of 2571 publicly available metagenomic samples (from eight main studies/datasets) that were reduced to 2424 after pre-processing and curation (see next sections). These are all the human-associated shotgun metagenomic studies with more than 70 samples and read length bigger than 70nt available as of January 2015. Six studies were devoted to the characterization of the human gut microbiome in presence of different diseases. Cirrhosis included 123 patients affected by liver cirrhosis and 114 healthy controls \[[33](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004977#pcbi.1004977.ref033)\]. Colorectal consisted of a total of 156 samples, 53 of which were affected by colorectal cancer \[[34](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004977#pcbi.1004977.ref034)\]. IBD represented the first available large metagenomic dataset and includes 124 individuals, 25 were affected by inflammatory bowel disease (IBD) \[[35](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004977#pcbi.1004977.ref035)\]. Obesity included 123 non-obese and 169 obese individuals \[[31](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004977#pcbi.1004977.ref031)\]. Two distinct studies were instead related to the alteration of the microbiome in subjects with type 2 diabetes (T2D). In the T2D dataset, 170 Chinese T2D patients and 174 non-diabetic controls were present \[[37](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004977#pcbi.1004977.ref037)\]. The WT2D focused on European women and included 53 T2D patients, 49 impaired glucose tolerance individuals and 43 normal glucose tolerance people \[[32](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004977#pcbi.1004977.ref032)\]. Among these six datasets, two of them comprise two independent stages. For cirrhosis, 181 and 56 samples were collected during the so defined discovery and validation phases, respectively. Similarly, for T2D, 145 and 199 samples were acquired during the first (stageI) and second (stageII) stages, respectively. Additionally, two studies focused on healthy subjects and not strictly related to the gut microbiome were also taken into account. HMP included samples collected from five major body sites (i.e., gastrointestinal tract, nasal cavity, oral cavity, skin, and urogenital tract). A subset of these samples were described in \[[1](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004977#pcbi.1004977.ref001)\]. Finally, skin was composed by 291 samples acquired from several different skin sites \[[36](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004977#pcbi.1004977.ref036)\]."

We traced the mentioned datasets with those present in ours based on the names given in Table 1 of the original paper.

```{r}
datasets <- c("liver_cirrhosis", "colorectal_cancer", "inflamatory_bowel_disease", "obesity","T2D", "WT2D","Human Microbiome Project", "Skin")
equivalent <- c("Quin_gut_liver_cirrhosis", "Zeller_fecal_colorectal_cancer", "metahit", "Chatelier_gut_obesity", "t2dmeta_long/short", "WT2D", "hmp/hmpii", "segre_Human_Skin")
declared_before_processing <- c(237, 156, 124, 292, 344, 145, 981, 291)
declared_after_processing <- c(232, 121, 110, 253, 344, 96, 981, 287)
found <- c(232, 134, 110, 278, 363, 145, 981, 291)

mentioned_vs_found <- tibble(datasets, equivalent, declared_before_processing, declared_after_processing, found)
mentioned_vs_found

mentioned_vs_found |> 
  pull(declared_after_processing) |> 
  sum()

mentioned_vs_found |> 
  pull(found) |> 
  sum()
```

The numbers of samples that we have for each dataset is equal to those obtained after the processing or intermediate between those and the total number before processing.

We will look better into this inconsistencies during cleaning. As for now, will proceed with the dataset as it is, though still not considering the datasets not mentioned as the source is not clear.

```{r}
traced_datasets <- c("Quin_gut_liver_cirrhosis", "Zeller_fecal_colorectal_cancer", "metahit", "Chatelier_gut_obesity", "t2dmeta_long", "t2dmeta_short", "WT2D", "hmp", "hmpii", "segre_Human_Skin")
selected_data <- dataset |> 
  filter(dataset_name %in% traced_datasets)
```

```{r}
target_dir <- "../data"

# save the dataset in the data fodler
write_csv(selected_data, str_c(target_dir, "/03_dat_selected.csv"))
```

---
format: 
  html:
    self-contained: true
---
# Cleaning the dataset

```{r}
library("tidyverse")
library("here")
library("viridis")
source("99_proj_func.R")
```


Building on top of the consideration made, we perform the cleaning. Here we had a major decision point about the direction the analysis will take.

```{r}
data_path <- here("data/03_dat_selected.csv")
dataset <- read_csv(data_path,
                    na = c("nd", "-", "na"),
                    show_col_types = FALSE)
```

The first thing we do is unify the original datasets that are splitted (t2d is splitted in t2dmeta_long / short, and the hmp is splitted in hmp/hmpii).

```{r}
dataset <- dataset |> 
  mutate(dataset_name = case_when(
    dataset_name == "t2dmeta_long" ~  "t2d",
    dataset_name == "t2dmeta_short" ~ "t2d",
    dataset_name == "hmpii" ~ "hmp",
    TRUE ~ dataset_name))
```

The dataset is divided in metadata and microorganism relative abundances. We divide the two dataset to facilitate cleaning:

```{r}
metadata <- dataset |>
  select(-starts_with("k__"))

dim_desc(metadata)
```

The wide variety of studies from which the data comes from results in a large number of study-specific metadata. This can be observed by plotting the amount of NA present in each of these.

```{r}
valid_counts <- metadata |> 
summarise(across(everything(),
                 ~sum(!is.na(.))),
          ) |> 
pivot_longer(everything(),
             names_to = "column_name",
             values_to = "valid_count")
valid_counts |> 
  ggplot(aes(x=valid_count)) +
  geom_histogram(binwidth = 30)
```

We can see that there are many columns with a lot / or even only missing values.

Many of these columns are dataset-specific, we can show that by plotting the columns group by the number of valid data and looking which dataset contain those valid datapoints.

```{r}
# For each column get the TOTAL number of non-NAs values
valid_values_count <- metadata |> 
  select(-dataset_name) |>  # we obviusly don't care about the data_set name column
  summarise(across(everything(),
                   ~ sum(!is.na(.)))) |> 
  pivot_longer(cols = everything(),
               names_to = "column",
               values_to = "valid_count") 

# Calculate the number of valid datapoint that each dataset has in each column
valid_values_by_dataset <- metadata |> 
  group_by(dataset_name) |> 
  summarise(across(everything(),
                   ~ sum(!is.na(.)),
                   .names = "{col}")) |> 
  pivot_longer(cols = -dataset_name, 
               names_to = "column", 
               values_to = "dataset_valid_count")

# Calculate the proportion of valid datapoint that each dataset has in each column
valid_proportions <- valid_values_by_dataset |> 
  left_join(valid_values_count, by = "column") |> 
  mutate(proportion = ifelse(valid_count == 0, 0, dataset_valid_count / valid_count))

# for each column select the most represented dataset (% > 90%, otherwise) if there is none the the column is considered mixed
most_represented_dataset <- valid_proportions |> 
  group_by(column) |> 
  arrange(desc(proportion))  |>  
  slice(1) |>   
  ungroup() |>
  mutate(most_representative_dataset = ifelse(proportion > 0.9, dataset_name, "no prevalent dataset (90% threshold)")) |> 
  mutate(proportion = ifelse(proportion > 0.9, proportion, NA))|> 
  select(-dataset_name)

# Divide the columns based on the amount of NAs they contain 
valid_count_distribution <- most_represented_dataset |> 
  group_by(valid_count,
           most_representative_dataset) |> 
  summarise(count = n(),
            .groups = "drop") |> 
  mutate(most_representative_dataset = factor(
    most_representative_dataset,
    levels = c(setdiff(unique(most_representative_dataset),
                       "no prevalent dataset (90% threshold)"),
               "no prevalent dataset (90% threshold)")
  ))

#FINALLY!!! We can plot the column distribution 
valid_entries_per_column_plot <- valid_count_distribution |>
  filter(valid_count != 0) |>
ggplot(aes(x = as.factor(valid_count), y = count, fill = most_representative_dataset)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Columns divided by amount of valid entries",
    x = "Number of valid values",
    y = "Number of columns",
    fill = "Most represented dataset",
    caption = "Columns having no valid values (125) are excluded for visualization purposes",
  ) +
  scale_fill_viridis(discrete = TRUE, option = "H") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10),
    axis.title.x = element_text(face = "bold", size = 12),
    axis.title.y = element_text(face = "bold", size = 12),
    plot.caption = element_text(face = "italic", size = 10, hjust = -1),
    panel.grid.minor.x = element_blank()) +
  coord_flip()

save_plot_custom(plot = valid_entries_per_column_plot, 
                 filename = "04_valid_entries.jpg")
valid_entries_per_column_plot
```

The columns having only 278 non-NAs values, are columns specific of the "obesity" dataset.

The columns having only 232 non-NAs values, are columns specific of the "Quin_gut_liver_cirrhosis" dataset.

The columns having only 363 non-NAs values, are columns specific of the "T2D" dataset.

The columns having only 145 non-NAs values, are columns specific of the "WT2D" dataset.

The columns having only 110 non-NAs values, are columns specific of the "metahit" dataset.

The columns having only 981 non-NAs values, are columns specific of the "hmp" dataset.

The columns having only 344 non-NAs values, are columns specific of the "hmp" dataset.

These columns are can be really important for analysis of single datasets, so we have to decide what to do them.

### Decision point

Because of what was said before there are two possible approaches:

1.  choose only a single dataset and focus the analysis on that one. This allows us to perform more significant analysis on the metadata and also makes the abundance data smaller, thus making it easier to work with it.

2.  keep all the datasets and only maintain the columns which are significant for most of them. This makes it difficult to perform significant analysis on the metadata as not many information are left. On the other hand we have much more data to study in terms of microbiota.

### Approach 1 - Focusing on WT2D

To the purpose of the project we decided that focusing our effort in the analysis of only a dataset was better. As it allows to better show what we have learned in the course. From the plot above we can see that the dataset having the largest amount of metadata columns (thus giving us many opportunity to do analysis) is the WT2D dataset ([original paper](https://doi.org/10.1038/nature12198)).

```{r}
metadata <- dataset |> 
  filter(dataset_name == "WT2D") |> 
  select(-starts_with("k__"))
```

We need to get rid of the columns containing to many missing values.

```{r}
valid_counts <- metadata |> 
summarise(across(everything(), ~sum(!is.na(.)))) |> 
pivot_longer(everything(), names_to = "column_name", values_to = "valid_count")
```

```{r}
to_remove <- valid_counts |> 
  filter(valid_count < 140) |> 
  pull(column_name)

metadata <- metadata |> 
  select(-all_of(to_remove))
```

We remove columns having the same value for all rows as they do not provide any information.

```{r}
metadata <- metadata |>
  select(where(~ n_distinct(.) > 1))
```

We see that the sampleID is just a lower case subjectID for every row, therefore we remove the subjectID.

```{r}
metadata |> 
  mutate(redundant = sampleID == str_to_upper(subjectID)) |> 
  select(redundant) |> 
  unique()

metadata <- metadata |> 
  select(-subjectID)
```

We see that the `classification` column is just another way of classifying the `disease` column with:

-   n (no disease) = ngt (normal glucose tolerance)
-   impaired_glucose_tolerance = igt
-   t2d = t2d (type 2 diabetes)

```{r}
metadata |> 
  select(disease, classification)

metadata <- metadata |>
  select(-classification)
```

```{r}
relevent_rows <- metadata |> 
  pull(sampleID)

abundance_data <- dataset |> 
  filter(sampleID %in% relevent_rows) |> 
  select(starts_with("k__"))
```

The only cleaning we can do on the abundances is that of removing columns that do not contain any data, i.e. columns the species of which is not present in any of the samples.

```{r}
abundance_data <- abundance_data |> 
  select(where(~ sum(.x, na.rm = TRUE) != 0))
```

Lastly we merge the metadata with the abundance data. We can do it without checking the row correspondence, as we did not remove any row or alter their order during the cleaning.

```{r}
dataset <- metadata |> 
  bind_cols(abundance_data)
```

```{r}
target_dir <- "../data"

# save the dataset in the data fodler
write_csv(dataset, str_c(target_dir, "/04_dat_clean.csv"))
```

### Approach 2 - We keep all datasets

Even though we are not going to follow this path we still provide an example of what the cleaning of this messier dataset could be done.

```{r}
dataset <- read_csv(data_path,
                    na = c("nd", "-", "na"),
                    show_col_types = FALSE)

metadata <- dataset |>
  select(-starts_with("k__"))
```

```{r}
valid_counts <- metadata |> 
summarise(across(everything(),
                 ~sum(!is.na(.)))) |> 
pivot_longer(everything(),
             names_to = "column_name",
             values_to = "valid_count")

to_remove <- valid_counts |> 
  filter(valid_count < 0.7 * nrow(metadata)) |> 
  pull(column_name)

metadata <- metadata |> 
  select(-all_of(to_remove))
```

Even with these approach we still some columns with a varying number of non-NAs values.

```{r}
metadata |> 
  filter(is.na(subjectID))

metadata <- metadata |> 
  filter(!is.na(subjectID))
```

We find that in the t2dmeta_long there are 19 samples are do not have any subjectID and are also missing a lot of metadata, this coincide with the hypothesis of these being the product of some error during the CSV production as by removing them we are able to perfectly match the number of samples expected for the t2d dataset (as found in during data selection).

Now we investigate the remaining data columns having NAs.

```{r}
metadata |> 
  filter(is.na(gender))
```

For `gender` we see that the samples not having a value belong to the WT2D or to the Chatelier_gut_obesity datasets. For the former we can verify by looking at the original paper that all the samples are taken from females, unfortunately the data is not recorded for the latter.

```{r}
metadata <- metadata |> 
  mutate(gender = ifelse(dataset_name == "WT2D",
                         "female", gender))
```

Moving on to the country column

```{r}
metadata |> 
  filter(is.na(country))
```

We can see that is the hmpii dataset to not have the country registered, this can be solved as the HMP project only took into account samples from citizens of the US, as can be seen by the hmp dataset.

One last check allow us to see that the metadata column are now greatly reduced and only contain the columns having the accepted missing values.

```{r}
valid_counts <- metadata |> 
summarise(across(everything(),
                 ~sum(!is.na(.)))) |> 
pivot_longer(everything(), names_to = "column_name",
             values_to = "valid_count")

valid_counts |> 
  filter(valid_count != nrow(metadata))
```

The last cleaning we do is simply to remove data not useful for future analysis

```{r}
metadata <- metadata |> 
  select(-sequencing_technology,
         -pubmedid,
         -`#SampleID`)
```

We can see that only a few columns are left.

```{r}
# rm(list = ls() |>  
#       keep(~ !is.function(get(.))) |>  
#       discard(~ . %in% ls()))
```

---
format: 
  html:
    self-contained: true
---
# Tidying the dataset

```{r}
library("tidyverse")
library("here")
```


We visualize the dataset and see that it is already tidy after the cleaning process, but we still make a couple of changes to make the dataset more readable.

```{r}
data_path <- here("data/04_dat_clean.csv")
dataset <- read_csv(data_path,
                    show_col_types = FALSE)
```

The three rules of tidy are:

-   Each row is a sample
-   Each column is a feature
-   Each cell has only one value

```{r}
head(dataset)
```

We can see that the three rules are already satisfied.

But we can still make some adjustments to prepare the dataset... first let's rename the disease column to make it easier to interpret.

```{r}
dataset <- dataset |> 
  rename(glucose_tolerance = disease) |>
  mutate(glucose_tolerance = case_when(
    glucose_tolerance == "impaired_glucose_tolerance" ~ "impaired",
    glucose_tolerance == "n" ~ "normal",
    TRUE ~ glucose_tolerance
  )) |> 
  mutate(glucose_tolerance = factor(glucose_tolerance,
                                     levels = c("normal",
                                                "impaired",
                                                "t2d"))) |> 
  arrange(glucose_tolerance)
```

The other change we can make is regarding the abundances... as for now the structure of the abundance columns is that of descending from kingdom to species and has an entry for each taxonomy level. While this can be useful to perform analysis at different levels, it also increases drastically the number of rows and also causes many values to be repeated if, for example, a single species is present for the whole kingdom.

Because of this we decided to focus on species abundance

```{r}
metadata <- dataset |> 
  select(-starts_with("k__"))

abundance <- dataset |> 
  select(which(str_count(names(dataset),
                         "\\|") == 6) & starts_with("k__"))

colnames(abundance) <- sub(".*s__",
                           "s_",
                           colnames(abundance))
```

Now each column represent the abundance of a specific species.

A key processing step is that of transforming the composite that in a way that can be compared across different samples.

```{r}
dataset <- metadata |> 
  bind_cols(abundance)
```

```{r}
target_dir <- "../data"

# save the dataset in the data folder
write_csv(dataset, str_c(target_dir, "/05_dat_tidy.csv"))
# from now on we are going to mantain a RData copy for the files as we want to mantain columns formatted as factor
file_path <- str_c(target_dir, "/05_dat_tidy.RData")
save(dataset, file = file_path)
```

---
format: 
  html:
    self-contained: true
---
# Augmentation

```{r}
library("tidyverse")
library("here")
```


```{r}
data_path <- here("data/05_dat_tidy.RData")
load(data_path)
```

Create a variable which groups together samples from patients having type 2 diabetes or being in the pre-diabetes state.

```{r}
dataset <- dataset |> 
  mutate(is_diseased = ifelse(glucose_tolerance == "t2d" |
                                glucose_tolerance == "impaired",
                              1,
                              0)) |>
  relocate(is_diseased,
           .after = glucose_tolerance)
```

Create a categorical classification based on the BMI.

```{r}
dataset <- dataset |> 
  mutate(BMI_class = case_when(
    bmi < 18.5 ~ "Underweight",
    bmi >= 18.5 & bmi < 25 ~ "Normal weight",
    bmi >= 25 & bmi < 30 ~ "Overweight",
    bmi >= 30 ~ "Obese"
  ) |> 
  factor(levels = c("Underweight", "Normal weight", "Overweight", "Obese"))) |>
  relocate(BMI_class,
           .after = bmi)
```

Create a variable to hold the ratio between high-density and low-density lipoproteins. This ratio is studied and used as a predictor for the insurgence of many cardiovascular diseases, the desired ratio is \>1 as hdl are the good fats while ldl are the bad ones.

```{r}
dataset <- dataset |> 
  mutate(hdl_to_ldl_ratio = hdl / ldl) |> 
  relocate(hdl_to_ldl_ratio,
           .after = ldl)
```

Create a variable for the HOMA-IR score (HOMA-IR (Homeostatic model assessment for insulin resistance) and its categories, a measure insulin resistance / sensitivity ([reference](https://doi.org/10.3390/medicina55050158)).

```{r}
dataset <- dataset |>
  mutate(`HOMA-IR` = fasting_glucose * fasting_insulin / 22.5,
         HOMA_category = case_when(
           `HOMA-IR` < 1.5 ~ "Healthy",
           `HOMA-IR` >= 1.5 & `HOMA-IR` < 2.5 ~ "At risk",
           `HOMA-IR` >= 2.5 & `HOMA-IR` < 5.0 ~ "Insulin Resistant",
           `HOMA-IR` >= 5.0 ~ "Severely Insulin Resistant"
         )) |>
  mutate(HOMA_category = factor(HOMA_category,
                                levels = c("Healthy", "At risk", "Insulin Resistant", "Severely Insulin Resistant"))) |> 
  relocate(`HOMA-IR`,
           .after = fasting_insulin) |> 
  relocate(HOMA_category,
           .after = `HOMA-IR`)
```

Another adjustment to do regards the abundance data, as it right now is composite which does not allow for direct comparison across samples. To prepare for future analysis we apply a center log ratio transformation.

```{r}
metadata <- dataset |> 
  select(-starts_with("s_"))
abundances <- dataset |> 
  select(starts_with("s_"))

rm(dataset)
```

```{r}
# verify that the rows sum to 1
abundances |> 
  rowwise() |> 
  mutate(row_sum = sum(c_across(everything()))) |> 
  select(row_sum)

# apply CLR
CLR_tranformed <- abundance |> 
  mutate(across(starts_with("s_"), ~ ifelse(. == 0, 1e-6, .))) |> 
  rowwise() |> 
  mutate(geom_mean = exp(mean(log(c_across(starts_with("s_")))))) |> 
  mutate(across(starts_with("s_"),~ log(. / geom_mean))) |> 
  select(-geom_mean)
```

```{r}
dataset <- metadata |> 
  bind_cols(CLR_tranformed)
```

```{r}
target_dir <- "../data"

write_csv(dataset, str_c(target_dir,
                         "/06_dat_augmented.csv"))

file_path <- str_c(target_dir, "/06_dat_augmented.RData")
save(dataset, file = file_path)
```

---
format: 
  html:
    self-contained: true
---
# Exploration of metadata

```{r}
library("tidyverse")
library("here")
library("ggridges")
library("patchwork")
library("viridis")
library("table1")

source("99_proj_func.R")
```


```{r}
data_path <- here("data/06_dat_augmented.RData")
load(data_path)
```

First, we want to get an overview of the metadata present in the dataset, before we analyze it.

In the table below, we find parameter values distributed based on glucose tolerance. We see here that there is only one underweight person; therefore, when we look at how values are distributed according to BMI class, we choose not to include it as it does not provide enough data information.

```{r}
dataset |> 
  table1::table1(x = formula(~ BMI_class + HOMA_category + cholesterol + statins + insulin| glucose_tolerance),
         data = _)
```

Our dataset contains samples taken from patients either having type II diabetes, an impaired tolerance to glucose or being healthy individuals.

We have access to many information regarding markers that correlate to the insurgence of diabetes, but let's start with the basics.

## General visualization

```{r}
distribution_by_country <- dataset |> 
  ggplot(aes(x = fct_infreq(country))) + 
  geom_bar(fill = "skyblue", color = "black") + 
  geom_text(stat = "count", aes(label = after_stat(count)), vjust = -0.5, size = 3) +
  labs(
    title = "Distribution of samples by country",
    x = "Country",
    y = "Number of Samples"
  ) +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))

save_plot_custom(
  plot = distribution_by_country,
  filename = "07_distribution_of_sample_by_countries.jpg"
)
distribution_by_country
```

```{r}
distribution_by_age <- dataset |> 
  ggplot(aes(x = age)) + 
  geom_histogram(fill = "skyblue", color = "black", binwidth = 0.5) + 
  geom_vline(
    aes(xintercept = mean(age, na.rm = TRUE)),
    color = "black", 
    linetype = "dashed", 
    linewidth = 0.5
  ) +
  labs(
    title = "Distribution of Samples by Age",
    x = "Age",
    y = "Number of Samples"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, hjust = 0.5)
  )

save_plot_custom(
  plot = distribution_by_age,
  filename = "07_distribution_of_sample_by_age.jpg"
)
distribution_by_age
```

We can say that our samples are collected from females living in central european / nordic countries, mainly Sweden, in the age range 69-72. This reflects what we expect from the paper.

### Diabetes specific visualization

Now we move on to more diabetes-specific metadata.

```{r}
distribution_by_glucose_tolerance <- dataset |>
  count(glucose_tolerance) |>
  mutate(percentage = n / sum(n) * 100) |>
  ggplot(aes(x = glucose_tolerance,
             y = percentage,
             fill = glucose_tolerance,
             label = str_c(round(percentage,digits = 2),"%"))) +
  geom_col(colour = "black",
           alpha = 0.6) +
  theme_minimal(base_size = 15) +
  labs(x = "",
       y = "",
       title = "Sample distribution in glucose tolerance groups") +
  geom_hline(yintercept = 0) +
  geom_text(vjust = -0.5, size = 5)+
  ylim(0,45)+
  theme(legend.position = "none",
        axis.text.y = element_blank())

save_plot_custom(
  plot = distribution_by_glucose_tolerance,
  filename = "07_distribution_of_sample_by_glucose_tolerance.jpg"
)
distribution_by_glucose_tolerance
```

Firstly, we observe how the samples are distributed across the glucose tolerance classes. They are almost equally distributed, this allows us to say that the future visualization have enough information to be significant.

```{r}
distribution_by_BMI <- dataset |>
  count(BMI_class) |>
  mutate(percentage = n / sum(n) * 100) |>
  ggplot(aes(x = BMI_class,
             y = percentage,
             fill = BMI_class,
             label = str_c(round(percentage,digits = 2),"%"))) +
  geom_col(colour = "black",
           alpha = 0.6) +
  theme_minimal(base_size = 15) +
  labs(x = "",
       y = "",
       title = "Distribution of samples into BMI categories") +
  geom_hline(yintercept = 0) +
  geom_text(vjust = -0.5, size = 5)+
  ylim(0,45)+
  theme(legend.position = "none",
        axis.text.y = element_blank(),
        plot.title = element_text(hjust = 0.5))

save_plot_custom(
  plot = distribution_by_BMI,
  filename = "07_distribution_of_sample_by_BMI.jpg"
  )
distribution_by_BMI
```

Then, we look at the distribution of BMI classes. We can see that the dataset is significantly enriched in overweight and obese subjects, this make sense as a higher BMI is known to increase the risk of developing diabetes.

```{r}
bmi_vs_glucose_tolerance <- dataset |> 
  mutate(bmi_group = cut(
    x = bmi,
    breaks = seq(from = 18,
                 to = 45,
                 by = 3))) |> 
  count(glucose_tolerance, bmi_group) |> 
  ggplot(aes(x = bmi_group,
             y = n,
             fill = glucose_tolerance)) +
  geom_col(position = position_dodge(
    preserve = "single"),
    colour = "black",
    alpha = 0.4) +
  geom_hline(yintercept = 0) +
  theme_minimal(base_size = 10) +
  labs(x = "BMI",
       y = "Count",
       title = "BMI count by glucose tolerance",
       fill = "Glucose tolerance: ") +
  theme(legend.position = "bottom",
        panel.grid.major.x = element_blank(),
        axis.text.x = element_text(vjust = 5))

save_plot_custom(
  plot = bmi_vs_glucose_tolerance,
  filename = "07_bmi_vs_glucose_tolerance.jpg"
)
bmi_vs_glucose_tolerance
```

BMI is an estimate of the amount of fat carried by a person, it is usefull when looking at diabetic people as obesity significantly increases the risk of developing diabetes ([reference](https://doi.org/10.14423/SMJ.0000000000000214)).

```{r}
stacked_bmi_vs_glucose_tolerance <- dataset |> 
  ggplot(aes(x = BMI_class, fill = glucose_tolerance)) + 
  geom_bar(color = "black") + 
  labs(
    x = "BMI",
    y = "Number of Samples"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, hjust = 0.5)
  )

save_plot_custom(
  plot = stacked_bmi_vs_glucose_tolerance,
  filename = "07_stacked_bmi_vs_glucose_tolerance.jpg"
)
stacked_bmi_vs_glucose_tolerance
```

## Visualization of different parameters vs glucose tolerance

Here we will focus just on visualizing the relationship between glucose tolerance and many other variables. The statistical significance of these results will be analysed in the analysis part of the project.

#### Markers for both type I and II diabetes

```{r}
ridges_hba1c_vs_glucose_tolerance <- dataset |> 
  ggplot(mapping = aes(x = hba1c,
                       y = glucose_tolerance,
                       fill = glucose_tolerance )) +
    geom_density_ridges(alpha = 0.5) +
    labs(x = "HbA1c [mmol/mol]",
         y = "glucose tolerance",
         title = "HbA1c and glucose tolerance") +
    theme_minimal(base_family = "Avenir",
                  base_size = 12) +
    theme(legend.position = "none")

save_plot_custom(
  plot = ridges_hba1c_vs_glucose_tolerance,
  filename = "07_hba1c_vs_glucose_tolerance.jpg"
)
ridges_hba1c_vs_glucose_tolerance
```

Hemoglobin A1C is hemoglobin bound to glucose, which can be used as a measure of average blood glucose level. High glucose is one of the hallmarks of diabetes. We can see the hba1c getting higher for diabetic patients ([reference](https://doi.org/10.4137/bmi.s38440)).

```{r}
hba1c_48_threshold <- dataset |>
  group_by(glucose_tolerance) |> 
  count(hba1c > 48) |>
  mutate(percentage = n / sum(n) * 100) |>
  ggplot(aes(x = glucose_tolerance,
             y = percentage,
             fill = glucose_tolerance,
             label = str_c(round(percentage,
                                 digits = 2),
                           "%"))) +
  geom_col(colour = "black",
           alpha = 0.4) +
  theme_minimal(base_size = 15) +
  theme(axis.text.x = element_text(
    angle = 45,
    hjust = 1)) +
  labs(x = "",
       y = "%",
       title = "% of people with HbA1c > 48 by glucose tolerance") +
  geom_hline(yintercept = 0) +
  geom_text(vjust = -0.5, size = 5) +
  ylim(0,45) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none" )

save_plot_custom(
  plot = hba1c_48_threshold,
  filename = "07_hba1c_48_threshold.jpg"
)
hba1c_48_threshold
```

The healthy threshold for hba1c has been identify at 48 mmol/mol ([reference](https://doi.org/10.2337/dc14-0886)).

```{r}
ridges_wc_vs_glucose_tolerance <- dataset |> 
  ggplot(mapping = aes(x = wc,
                      y = glucose_tolerance,
                      fill = glucose_tolerance )) +
    geom_density_ridges(alpha = 0.5) +
    labs(x = "Waist circumference [cm]",
         y = "",
         title = "Glucose Tolerance vs Waist Circumfrence") +
  theme_minimal(base_family = "Avenir",
                  base_size = 12) +
    theme(legend.position = "none")

save_plot_custom(
  plot = ridges_wc_vs_glucose_tolerance,
  filename = "07_ridges_wc_vs_glucose_tolerance.jpg"
)
ridges_wc_vs_glucose_tolerance
```

We saw that the WC parameter was a statistically significant parameter in predicting type 2 diabetes. In the plot below, we observe that the data from the type 2 diabetes group is skewed to the right.

```{r}
ridges_hdl_vs_glucose_tolerance <- dataset |> 
  ggplot(mapping = aes(x = hdl,
                      y = glucose_tolerance,
                      fill = glucose_tolerance )) +
    geom_density_ridges(alpha = 0.5) +
    labs(x = "HDL [mmol/L]",
         y = "Glucose Tolerance",
         title = "HDL and glucose tolerance ") +
    theme_minimal(base_family = "Avenir",
                  base_size = 12) +
    theme(legend.position = "none")

save_plot_custom(
  plot = ridges_hdl_vs_glucose_tolerance,
  filename = "07_ridges_hdl_vs_glucose_tolerance.jpg"
)
ridges_hdl_vs_glucose_tolerance
```

We investigate how the HDL distribution differs between the glucose tolerance groups, where we see that for the type 2 diabetic group, the distribution is slightly left-skewed ([reference](https://doi.org/10.1586/erc.11.182)).

#### Markers for discriminating type I and type II

```{r}
fasting_insuling_vs_glucose_tolerance_bar <- dataset |> 
  mutate(fasting_insulin_group = cut(
    x = fasting_insulin,
    breaks = seq(from = 0,
                 to = 70,
                 by = 5))) |> 
  count(glucose_tolerance, fasting_insulin_group) |> 
  ggplot(aes(x = fasting_insulin_group,
             y = n,
             fill = glucose_tolerance)) +
  geom_col(position = position_dodge(
    preserve = "single"),
    colour = "black",
    alpha = 0.4) +
  geom_hline(yintercept = 0) +
  theme_minimal(base_size = 10) +
  labs(x = "Fasting insulin [pmol/L]",
       y = "n",
       title = "Fasting insulin count grouped by glucose tolerance",
       fill = "Glucose tolerance: ")+
  theme(plot.title = element_text(hjust = 0.5),
        legend.position = "bottom",
        panel.grid.major.x = element_blank(),
        axis.text.x = element_text(vjust = 5))

save_plot_custom(
  plot = fasting_insuling_vs_glucose_tolerance_bar,
  filename = "07_fasting_insuling_vs_glucose_tolerance_bar.jpg"
)
fasting_insuling_vs_glucose_tolerance_bar
```

From literature we know that Insulin remains in the blood longer in type II diabetic patients, this can be seen from the graph above, where in the higher categories only diabetic subjects are present.

```{r}
fasting_insuling_vs_glucose_tolerance <- dataset |> 
  ggplot(mapping = aes(x = fasting_insulin,
                      y = glucose_tolerance,
                      fill = glucose_tolerance )) +
    geom_density_ridges(alpha = 0.5) +
    labs(x = "Fasting insulin [pmol/L]",
         y = "Glucose tolerance",
         title = "Fasting insulin and glucose tolerance ") +
    theme_minimal(base_family = "Avenir",
                  base_size = 12) +
    theme(legend.position = "none")

save_plot_custom(
  plot = fasting_insuling_vs_glucose_tolerance,
  filename = "07_fasting_insuling_vs_glucose_tolerance_ridges.jpg"
)
fasting_insuling_vs_glucose_tolerance
```

We also look at how fasting insulin is distributed according to glucose tolerance, and we see that the glucose tolerance for fasting insulin is higher for the type 2 diabetes group.

```{r}
c_peptide_vs_bmi_glucose_tolerance <- dataset|>
  filter(BMI_class != "Underweight") |> 
  ggplot(aes(x = glucose_tolerance,
             y = `c-peptide`,
             fill = BMI_class)) +
  geom_boxplot(position = position_dodge(
    preserve = "single"), 
    alpha = 0.4) +
  theme_minimal(base_size = 15) +
  theme(legend.position = "bottom",
        plot.title = element_text(hjust = 0.5)) +
    labs(x = "BMI class",
         y = "c-peptide [ng/mL]",
         title = "c-peptide concentration",
         fill = "Glucose tolerance: ")

save_plot_custom(
  plot = c_peptide_vs_bmi_glucose_tolerance,
  filename = "07_c_peptide_vs_bmi_glucose_tolerance.jpg"
)
c_peptide_vs_bmi_glucose_tolerance
```

The c-peptide is a 31-aa sequence that binds the A and B chain of the proinsuline and is removed to produce insuline. Therefore its levels are used to distinguish between patients producing (type II) or non producing (type I) insulin. The insulin level is higher in type II as the body tries to maintain normal blood sugar levels ([reference](https://doi.org/10.1111/dom.14785)).

```{r}
gad_ab_vs_bmi_glucose_tolerance <- dataset|>
  filter(BMI_class != "Underweight") |> 
  filter(`gad-antibodies` < 20) |> 
  ggplot(aes(x = BMI_class,
             y = `gad-antibodies`,
             fill = glucose_tolerance)) +
  geom_boxplot(position = position_dodge(
    preserve = "single"), 
    alpha = 0.4) +
  theme_minimal(base_size = 15) +
  theme(legend.position = "bottom",
        plot.title = element_text(hjust = 0.5)) +
    labs(x = "BMI class",
       y = "GAD-antibodies [U/mL]",
       title = "GAD-antibodies concentration",
       fill = "Glucose tolerance: ")

save_plot_custom(
  plot = gad_ab_vs_bmi_glucose_tolerance,
  filename = "07_gad_ab_vs_bmi_glucose_tolerance.jpg"
)
gad_ab_vs_bmi_glucose_tolerance
```

We know from the literature that GAD antibodies are a parameter used to differentiate between type 1 and type 2 diabetes. In type 1 there is a decrease in insulin production which can be caused by production GAD antibodies that cause the immune system to attack the beta cells of the pancreas that produce insulin. Here we do not see changes in GAD antibodies as our dataset contains samples from type 2 diabetes patients ([reference](https://doi.org/10.2337/db09-0747)).

```{r}
dataset|>
  filter(`gad-antibodies` > 20) 
```

This single example shows a concentration of gad antibodies more compatible with type I diabetes.

#### Additional exploratory plots

```{r}
linear_wc_hba1c_glucose_tolerance <- dataset |>
  ggplot(aes(x = wc,
             y = hba1c,
             colour = glucose_tolerance)) +
  geom_point(size = 2,
             alpha = 0.4) +
  geom_smooth(method = "lm",
              se = FALSE) +
  labs(x = "WC [cm]",
       y = "HbA1c [mmol/mol]",
       title = "WC vs HbA1c groupt by glucose tolerance",
       colour = "Glucose tolerance: ")+
  theme_minimal(base_size = 12)

save_plot_custom(
  plot = linear_wc_hba1c_glucose_tolerance,
  filename = "07_linear_wc_hba1c_glucose_tolerance.jpg"
)
linear_wc_hba1c_glucose_tolerance
```

We were then interested in studying the relationship between WC, HbA1c, and glucose tolerance, where we see that the data points for the type 2 diabetes group are quite different from the normal and impaired groups. This is because both hba1c and wc correlate positively with diabetes.

```{r}
linear_hdl_hba1c_glucose_tolerance <- dataset |>
  ggplot(aes(x = hdl,
             y = hba1c,
             colour = glucose_tolerance)) +
  geom_point(size = 2,
             alpha = 0.5) +
  labs(x = "HDL [mmol/L]",
       y = "Hemoglobin A1C [mmol/mol]",
       title = "HDL vs Hemoglobin A1C groupt by glucose tolerance",
       colour = "Glucose tolerance: ") +
  theme_minimal(base_size = 12)

save_plot_custom(
  plot = linear_wc_hba1c_glucose_tolerance,
  filename = "07_dlinear_wc_hba1c_glucose_tolerancee.jpg"
)
linear_hdl_hba1c_glucose_tolerance
```

In the figure below, we see a point plot of HDL on the x-axis and Hemoglobin A1C on the y-axis, filtered by glucose tolerance. We observe that Hemoglobin A1C is a better discriminatory factor.

```{r}
hdl_glucose_tolerance <- dataset |> 
  ggplot(aes(x = glucose_tolerance,
             y = hdl,
             fill = glucose_tolerance)) + 
  geom_boxplot(color = "black") + 
  labs(
    x = "Glucose tolerance",
    y = "HDL [mmol/L]",
    title = "HDL vs glucose tolerance"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, hjust = 0.5)
  )

save_plot_custom(
  plot = hdl_glucose_tolerance,
  filename = "07_hdl_glucose_tolerance.jpg"
)
hdl_glucose_tolerance
```

We can see that the HDL levels lower with the glucose tolerance decreasing, this is in agreement with the literature that tells that HDL is lowered in diabetic patients.

```{r}
ldl_glucose_tolerance <- dataset |> 
  ggplot(aes(x = glucose_tolerance,
             y = ldl,
             fill = glucose_tolerance)) + 
  geom_boxplot(color = "black") + 
  labs(
    x = "Glucose tolerance",
    y = "LDL level [mmol/L]",
    title = "LDL level vs glucose tolerance"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, hjust = 0.5)
  )

save_plot_custom(
  plot = ldl_glucose_tolerance,
  filename = "07_ldl_glucose_tolerance.jpg"
)
ldl_glucose_tolerance
```

Strangely we see that same for the LDL, which instead is expected to either lower or be similar across the categories.

```{r}
hb1ac_glucose_tolerance <- dataset |> 
  ggplot(aes(x = glucose_tolerance,
             y = hba1c,
             fill = glucose_tolerance)) + 
  geom_boxplot(color = "black") + 
  labs(
    x = "Glucose tolerance",
    y = "Hemoglobin A1C [mmol/mol]",
    title = " Hemoglobin A1C vs glucose tolerance"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, hjust = 0.5)
  )

save_plot_custom(
  plot = hb1ac_glucose_tolerance,
  filename = "07_hb1ac_glucose_tolerance.jpg"
)
hb1ac_glucose_tolerance
```

## The effect of treatment

First, we are interested in investigating how many people in each glucose tolerance category are on statins treatment. We see that there are 26 people with type 2 diabetes who are on statins. We only consider statins as the treatment, as we know from the table that less than 5% of the samples are on insulin.

Statins are used as preventive treatment against cardiovascular diseases, but have been linked to an increased risk of developing diabetes ([reference](https://doi.org/10.3389/fendo.2023.1239335)).

```{r}
count_statins_graph <- dataset |>
  group_by(glucose_tolerance) |> 
  count(statins) |>
  filter(statins =="y") |> 
  ggplot(aes(x = glucose_tolerance,
             y = n,
             fill = glucose_tolerance,
             label = n)) +
  geom_col(colour = "black",
           alpha = 0.4) +
  theme_minimal(base_size = 15) +
  labs(x = "",
       y = "on statins") +
  geom_hline(yintercept = 0) +
  geom_text(vjust = -0.5, size = 5)+
  ylim(0,45)+
  theme(legend.position = "none",
        axis.text.y = element_blank())

save_plot_custom(
  plot = count_statins_graph,
  filename = "07_statins_amuount.jpg"
)
count_statins_graph

percentage_statins_graph <- dataset |>
  group_by(glucose_tolerance) |> 
  count(statins) |>
  mutate(percentage = n / sum(n) * 100)|>
  filter(statins =="y") |> 
  ggplot(aes(x = glucose_tolerance,
             y = n,
             fill = glucose_tolerance,
             label = str_c(round(percentage,digits = 2),"%"))) +
  geom_col(colour = "black",
           alpha = 0.4) +
  theme_minimal(base_size = 15) +
  labs(x = "",
       y = "% received statins",
       title = "% of patient groups recieve statin treatment") +
  geom_hline(yintercept = 0) +
  geom_text(vjust = -0.5, size = 5)+
  ylim(0,45)+
  theme(legend.position = "none",
        axis.text.y = element_blank())

save_plot_custom(
  plot = percentage_statins_graph,
  filename = "07_percentage_statins_graph.jpg"
)
percentage_statins_graph
```

Now we want to compare within the type 2 diabetes group whether fasting insulin is influenced by being on medication. In the plot below, we see that fasting insulin is not affected by the medication, but the cholesterol level is lower when on medication.

```{r}
linear_fasting_insuline_cholesterol <- dataset |> 
  filter(glucose_tolerance == "t2d") |> 
  ggplot(aes(x = fasting_insulin,
             y = cholesterol,
             colour = statins)) +
  geom_point(size = 2,
             alpha = 0.4) +
  geom_smooth(method = "lm",
              se = FALSE) +
  labs(x = "Fasting insulin [pmol/L]",
       y = "Cholesterol [mmol/L]",
       title = "Fasting insulin vs cholesterol grouped by 
       statins for type 2 diabetes patients",
       colour = "Recieve statins: ") +
  theme_minimal(base_size = 12)

save_plot_custom(
  plot = linear_fasting_insuline_cholesterol,
  filename = "07_linear_fasting_insuline_cholesterol.jpg"
)
linear_fasting_insuline_cholesterol
```

We also want to see if the medication has an effect on c-peptide and HDL, where we see that the difference is minor.

```{r}
linear_c_peptide_hdl <- dataset |> 
  filter(glucose_tolerance == "t2d") |> 
  ggplot(aes(x = `c-peptide`,
             y = hdl,
             colour = statins)) +
  geom_point(size = 2,
             alpha = 0.4) +
  geom_smooth(method = "lm",
              se = FALSE) +
  labs(x = " c-peptide [ng/mL]",
       y = "HDL [mmol/L]",
       title = "c-peptide vs HDL grouped by statins for 
       type 2 diabetes patients",
       colour = "Recieve statin: ")+
  theme_minimal(base_size = 12)

save_plot_custom(
  plot = linear_c_peptide_hdl,
  filename = "07_linear_c_peptide_hdl.jpg"
)
linear_c_peptide_hdl
```

We can see that the number of obese and overweight people increases in glucose impaired and diabetic categories.

```{r}
#split on BMI
statins_cholesterol <- dataset |> 
  filter(BMI_class != "Underweight") |> 
  pivot_longer(cols = c(statins),
               names_to = "variable", 
               values_to = "category") |> 
  ggplot(aes(x = category, y = cholesterol, fill = category)) + 
  geom_boxplot(color = "black") +
  facet_wrap(~variable) +
  labs(
    x = "",
    y = "Cholesterol [mmol/L]",
    fill = "Recieve statin"
  ) +
  facet_wrap(~glucose_tolerance) +
  theme_minimal() +
  theme(
  )

save_plot_custom(
  plot = statins_cholesterol,
  filename = "07_statins_cholesterol.jpg"
)
statins_cholesterol
```

We can see that the treatment with statins have the effect of lowering cholesterol, which is coherent with what's expected.

```{r}
# # clean environment
# rm(list = ls() |>  
#       keep(~ !is.function(get(.))) |>  
#       discard(~ . %in% ls()))
```

---
format: 
  html:
    self-contained: true
---
# Exploration of the abundances

```{r}
library("tidyverse")
library("here")
library("ggridges")
library("patchwork")
source("99_proj_func.R")
```


```{r}
data_path <- here("data/06_dat_augmented.RData")
load(data_path)
```

### Abundances visualization

```{r}
abundance <- dataset |> 
  select(starts_with("s_"))

mean_species_abundances <- dataset |> 
  select(glucose_tolerance) |> 
  bind_cols(abundance) |> 
  group_by(glucose_tolerance) |> 
  summarise(across(everything(),
                   \(x) mean(x,
                             na.rm = TRUE))) |>
  pivot_longer(
    cols = -glucose_tolerance,
    names_to = "species", 
    values_to = "mean_abundance"
  ) |> 
  pivot_wider(
    names_from = glucose_tolerance,
    values_from = mean_abundance
  ) |> 
  arrange(desc(normal))
```

```{r}
# reshape to work on species
result_long <- mean_species_abundances |> 
  pivot_longer(cols = -species, names_to = "glucose_tolerance",
               values_to = "mean_abundance")

# get the top 10 abundant species for each glucose_tolerance class
top_species_per_glucose_tolerance <- result_long |> 
  group_by(glucose_tolerance) |> 
  slice_max(mean_abundance,
            n = 10) |> 
  ungroup()

# Create custom labels for the plot
custom_labels <- c(
  "normal" = "Healthy",
  "impaired" = "Impaired Glucose Tolerance",
  "t2d" = "Type 2 Diabetes"
)

# Show the top 10s
top10_species_vs_glucose_tolerance <- top_species_per_glucose_tolerance |> 
ggplot(aes(x = reorder(species, mean_abundance),
           y = mean_abundance,
           fill = glucose_tolerance)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  facet_wrap(~ glucose_tolerance, scales = "free_y",
             ncol = 1,
             labeller = labeller(glucose_tolerance = custom_labels)) +  
  labs(
    title = "Top 10 Bacterial Species in health groups",
    x = "Bacterial Species",
    y = "Mean Abundance",
    fill = "glucose_tolerance"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.y = element_text(size = 7),
    strip.text = element_text(size = 10),
    axis.text.x = element_text(size = 9, angle = 0, hjust = 0.5) 
  )

save_plot_custom(
  plot = top10_species_vs_glucose_tolerance,
  filename = "08_top10_species_vs_glucose_tolerance.jpg"
)
top10_species_vs_glucose_tolerance
```

Here we see that the top present species are the same, but this could simply be because they are common gut species.

```{r}
species_heatmap <- mean_species_abundances |> 
  arrange(desc(t2d)) |>
  #head(100) |> 
  pivot_longer(cols = -species,
               names_to = "glucose_tolerance",
               values_to = "mean_abundance") |> 
    ggplot(aes(x = glucose_tolerance,
               y = species,
               fill = mean_abundance)) +
      geom_tile() +
      scale_fill_gradient2(low = "purple",
                           mid = "white",
                           high = "green",
                           midpoint = 2) + 
      labs(
        title = "Mean Abundance of Bacterial Species",
        x = "Glucose tolerance",
        y = "Bacterial Species",
        fill = "Mean Abundance"
      ) +
      theme_minimal() +
  theme(axis.text.y = element_blank())

save_plot_custom(
  plot = species_heatmap,
  filename = "08_species_heatmap.jpg"
)
species_heatmap
```

Even by looking at the whole microbiota there does not seem to be too much difference between this groups.

```{r}
species_difference <- mean_species_abundances |> 
  mutate(difference = normal-t2d) |> 
  select(species, difference) |> 
  mutate(comparison = ifelse(difference > 0,
                             "normal>t2d", "t2d>normal")) |> 
  mutate(difference = abs(difference)) |> 
  arrange(desc(difference))
```

```{r}
most_different_species <- species_difference |> 
  head(30) |> 
  ggplot(aes(x = difference,
             y = reorder(species, difference),
             fill = comparison)) + 
  geom_bar(stat = "identity") + 
  labs(
    x = "Absolute Difference in Abundance",
    y = "Species",
    title = "Difference in species Abundance between healthy and T2D"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, hjust = 1)
  )

save_plot_custom(
  plot = most_different_species,
  filename = "08_most_different_species.jpg"
)
most_different_species
```

Here we can see which are the 30 species that differ the most between healthy and diabetic patients. These can be useful for future analysis or by looking at the literature.

Even though we saw in the p-value test that there were no statistical significant differences among the distribution of bacteria between the normal and T2D groups, we were still interested in seeing where the data for the bacteria show the most variation.

We see that for most of the groups, the value of *s_Escherichia_coli* is almost the same, but we observe a few healthy samples with higher levels.

```{r}
ecoli_vs_glucose_tolerance <- dataset |> 
  mutate(s_Escherichia_coli_group = cut(
    x = s_Escherichia_coli,
    breaks = seq(from = 0.000,
                 to = 40,
                 by = 5),
    include.lowest = TRUE)) |> 
  count(glucose_tolerance,s_Escherichia_coli_group) |> 
  ggplot(aes(x = s_Escherichia_coli_group,
             y = n,
             fill = glucose_tolerance)) +
  geom_col(position = position_dodge(
    preserve = "single"),
    colour = "black",
    alpha = 0.4) +
  geom_hline(yintercept = 0) +
  theme_minimal(base_size = 10) +
  labs(x = "s_Escherichia_coli",
       y = "Count",
       title = "s_Escherichia_coli count group by glucose tolerance",
       fill = "glucose tolerance: ")+
  theme(legend.position = "bottom",
        panel.grid.major.x = element_blank(),
        axis.text.x = element_text(vjust = 5))

save_plot_custom(
  plot = ecoli_vs_glucose_tolerance,
  filename = "08_ecoli_vs_glucose_tolerance.jpg"
)

ecoli_vs_glucose_tolerance
```

Then we also want to investigate where the combination of the two most different bacteria would provide more insight, but as we see below, we cannot find a meaningful relationship.

```{r}
ecoli_vs_raminococcus_glucose_tolerance <- dataset |>
  ggplot(aes(x = s_Escherichia_coli,
             y = s_Ruminococcus_sp_5_1_39BFAA,
             colour = glucose_tolerance)) +
  geom_point(size = 2,
             alpha = 0.4) +
  labs(x = "s_Escherichia_coli",
       y = "s_Ruminococcus_sp_5_1_39BFAA",
       title = "s_Escherichia_coli vs s_Ruminococcus_sp_5_1_39BFAA groupt by glucose tolerance",
       colour = "Glucose tollerance: ")+
  theme_minimal(base_size = 10)

save_plot_custom(
  plot = ecoli_vs_raminococcus_glucose_tolerance,
  filename = "08_ecoli_vs_raminococcus_glucose_tolerance.jpg"
)
ecoli_vs_raminococcus_glucose_tolerance
```

---
format: 
  html:
    self-contained: true
---
# Metadata analysis

```{r}
library("tidyverse")
library("here")
library("broom")
library("vegan")
source("99_proj_func.R")
```


Now we are going to explore the correlation between metadata columns, and check if there are statistically significant differences between healthy and diseased individuals.

```{r}
data_path <- here("data/06_dat_augmented.RData")
load(data_path)
```

What does impaired glucose tolerance mean? It means that blood sugar levels are elevated but not enough to warrant a diagnosis of diabetes.

### Correlation analysis

Calculating the correlation matrix on a subset of our data will tell us about linear relationships between data variables.

```{r}
# Select numeric columns after excluding ones starting with "s_"
corr_data <- dataset |> 
  select(-starts_with("s_")) |> 
  select(where(~ is.numeric(.x))) 

# Normalize columns, accounting for NA values
corr_normalized <- corr_data |> 
  mutate(across(everything(),
                ~ ifelse(is.na(.), mean(., na.rm = TRUE), .))) |> # Impute NA with column mean
  mutate(across(everything(),
                ~ (. - mean(., na.rm = TRUE)) / sd(., na.rm = TRUE))) 

# Compute the covariance matrix
cov_matrix <- (t(as.matrix(corr_normalized)) %*% as.matrix(corr_normalized)) / 
  (nrow(corr_normalized) - 1)

# Convert the covariance matrix to a correlation matrix
cor_matrix <- cov2cor(cov_matrix)

# Pivot the correlation matrix to long format
melted_cor_matrix <- as.data.frame(cor_matrix) |> 
  rownames_to_column(var = "Var1") |> 
  pivot_longer(-Var1, names_to = "Var2", values_to = "value")

# Plot values in color squares to visualize correlation
correlation_matrix <- ggplot(data = melted_cor_matrix,
       aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  geom_text(aes(label = round(value, 2)),
            color = "black",
            size = 2) + 
  scale_fill_gradient2(low = "blue",
                       high = "red",
                       mid = "white", 
                       midpoint = 0,
                       limit = c(-1, 1),
                       space = "Lab", 
                       name = "Correlation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, 
                                   size = 10,
                                   hjust = 1,
                                   vjust = 0.2),
        axis.title.x = element_blank(),
        axis.title.y = element_blank()) +
  coord_fixed()

save_plot_custom(
  plot = correlation_matrix,
  filename = "09_correlation_matrix.jpg"
)
correlation_matrix
```

Unfortunately there is not a lot we can conclude from the correlation matrix... the only significant correlation are between the waist circumference and the bmi (0.8), which make sense as lager waist usually are due to accumulated fat, or more in general, with heavier individuals. The strongest correlation is between ldl and cholesterol, but it is trivial given that the total cholesterol contains the ldl measurement. The most interesting correlation is that between fasting_insulin and c-peptide, as they are both specific markers for type II diabetes relating to the quantity of insulin produced.

```{r}
corval_lm <- dataset |>
  summarise(PCC = cor(x = bmi,
                      y = wc,
                      use = "complete.obs",
                      method = "pearson"))

bmi_wc_correlation <- dataset |>
  ggplot(aes(x = bmi,
             y = bmi)) +
  geom_point(size = 2,
             color = "red",
             alpha = 0.5) +
  geom_smooth(method = "lm") +
  labs(x = "WC [cm]",
       y = "Bmi",
       title = "Bmi vs wc")+
  labs(subtitle = str_c("PCC = ", corval_lm  |>  pull(PCC) |>round(3)))+
  theme_minimal(base_size = 12)

save_plot_custom(
  plot = bmi_wc_correlation,
  filename = "09_bmi_wc_correlation.jpg"
)
bmi_wc_correlation
```

### Statistical analysis of metadata

Now we are interested in doing a p-value test to study which of the parameters of the metadata are relevant to describing T2D. We compare between the normal and type 2 diabetes group.

We transform our data from wide to long format. We do not test on non-continuous variables.

```{r}
dataset_subsection_long <- dataset |> 
  select(-starts_with("s_")) |>                 
  select(where(~is.numeric(.x))) |>             
  pivot_longer(cols = -is_diseased,             
               names_to = "data_point",
               values_to = "value")
```

We group the data according to the type of data point, and each data point gets its own table by nesting. Then, the data is ungrouped again.

```{r}
dataset_subsection_long_nested <- dataset_subsection_long |>
  group_by(data_point) |> 
  nest() |> 
  ungroup()

dataset_subsection_long_nested
```

Now we set up a linear model for each metadata variable.

```{r}
dataset_subsection_aug_long_nested <- dataset_subsection_long_nested |> 
  group_by(data_point) |> 
  mutate(model_object = map(.x = data,
                   .f = ~lm(formula = value ~ is_diseased,
                            data = .x))) |> 
  mutate(model_object_tidy = map(.x = model_object,
                                 .f = ~tidy(x = .x,
                                            conf.int = TRUE,
                                            conf.level = 0.95)))
  
dataset_subsection_aug_long_nested
```

Then we try to pull out the model where the parameter variable BMI is used to describe T2D

```{r}
dataset_subsection_aug_long_nested |> 
  filter(data_point == "bmi") |> 
  pull(model_object_tidy)
```

We then unnest the model so that we can access the information about the model.

```{r}
dataset_subsection_estimates <- dataset_subsection_aug_long_nested |> 
  unnest(model_object_tidy)
dataset_subsection_estimates
```

```{r}
dataset_subsection_estimates <- dataset_subsection_estimates |> 
  filter(term == "is_diseased") |> 
  select(data_point, p.value, estimate, conf.low, conf.high) |> 
  ungroup()
dataset_subsection_estimates
```

We then create two new parameters, q.value and is_significant, which help us test if the data point is statistically significant at an alpha = 0.05 level. We find that the values for HDL, WHR, WC, cholesterol, fasting insulin, HbA1c, and C-peptide are significant at the alpha = 0.05 level.

```{r}
dataset_subsection_estimates <- dataset_subsection_estimates |>
  mutate(q.value = p.adjust(p.value),
         is_significant = case_when(q.value <= 0.05 ~ "yes",
                                    q.value > 0.05 ~ "no"))
dataset_subsection_estimates |> 
  filter(is_significant == "yes")
```

Then we create a plot of the significant parameter values, where on the x-axis we have Estimates (95% CIs) of the difference, and on the y-axis we have the significant parameters.

```{r}
significant_different_feature <- dataset_subsection_estimates |> 
  filter(is_significant == "yes") |> 
  ggplot(aes(x = estimate,
             y = fct_reorder(data_point, estimate),
             xmin = conf.low,
             xmax = conf.high)) +
  geom_vline(xintercept = 0) +
  geom_errorbarh() +
  geom_point() +
  theme_minimal(base_size = 12) +
  theme(plot.title = element_text(hjust = 1)) +
  labs(x = "Estimates (95%CIs)",
       y = expression("Significant different features (alpha = 0.05)"),
       title = "Parameters associated with type 2 diabetes")

save_plot_custom(
  plot = significant_different_feature,
  filename = "09_significant_different_feature.jpg"
)
significant_different_feature
```

We can see that the significantly different (p.value \> 0.05) variables are many of those that where observed during previous visualization, in particular we got fasting insulin and fasting glucose, which obviuosly mean that the HOMA-IR score is also significant. We also have the hemoglobin a1c and the c-peptide, which we have already talk about as important type II diabetes markers. Lastly adinopectin is also significantly less present in diabetic people, which is in agreement as it is a hormone essential for insulin sensitivity.

---
format: 
  html:
    self-contained: true
---
# Analysis of species abundances

```{r}
library("tidyverse")
library("here")
library("broom")
library("vegan")
source("99_proj_func.R")
```


```{r}
data_path <- here("data/06_dat_augmented.csv")
dataset <- read_csv(data_path,
                    na = c("nd", "-", "na"),
                    show_col_types = FALSE)
```

### Assessing relationships between species abundance and metadata features

Let's analyze the diversity between classes based on microbiota composition.

```{r}
abundances <- dataset |> 
  select(sampleID, glucose_tolerance, BMI_class, starts_with("s_"))

pca_fit <- abundances |> 
  select(where(is.numeric)) |> 
  prcomp(scale = TRUE)

pca_plot <- pca_fit |> 
  augment(abundances) |> 
  ggplot(aes(.fittedPC1, .fittedPC2)) + 
  geom_point(size = 1.5)

save_plot_custom(
  plot = pca_plot,
  filename = "10_pca_plot.jpg"
)
pca_plot
```

We see that there is an outlier in the data that we can remove for visualization sake.

```{r}
outlier <- pca_fit |> 
  augment(abundances) |> 
  select(-starts_with("s_")) |> 
  filter(.fittedPC1 < -30) |> 
  pull(sampleID)
```

```{r}
abundances <- abundances |> 
  filter(sampleID != outlier)

pca_fit <- abundances |> 
  select(where(is.numeric)) |> 
  prcomp(scale = TRUE)

variance_explained <- pca_fit |> 
  tidy(matrix = "eigenvalues") |> 
  mutate(percent_explained = round(percent * 100, 2))

pc1_var <- variance_explained |>
  filter(PC == 1) |>
  pull(percent_explained)
pc2_var <- variance_explained |>
  filter(PC == 2) |>
  pull(percent_explained)

pca_glucose_tolerance <- pca_fit |> 
  augment(abundances) |> 
  ggplot(aes(.fittedPC1, .fittedPC2, color = glucose_tolerance)) + 
  geom_point(size = 1.5) + 
  labs(title = "PCA of glucose tolerance classes based on microbiota composition",
       x = str_c("PC1 (", pc1_var, "%)"),
       y = str_c("PC2 (", pc2_var, "%)"),
       color = "Glucose tolerance")

save_plot_custom(
  plot = pca_glucose_tolerance,
  filename = "10_pca_glucose_tolerance.jpg"
)
pca_glucose_tolerance


pca_BMI <- pca_fit |> 
  augment(abundances) |> 
  ggplot(aes(.fittedPC1, .fittedPC2, color = BMI_class)) + 
  geom_point(size = 1.5) + 
  labs(title = "PCA of BMI classes based on microbiota composition", 
       x = str_c("PC1 (", pc1_var, "%)"),
       y = str_c("PC2 (", pc2_var, "%)"),
       color= "BMI Class")

save_plot_custom(
  plot = pca_BMI,
  filename = "10_pca_BMI.jpg"
)
pca_BMI
```

Even by removing the outlier, the plots show that the samples do not cluster in any significant way, either for the BMI or for the glucose tolerance, this is in agreement with the observation made so far.

We perform a PERMANOVA test to quantify the difference between the BMI groups, testing the following:

-   Null hypothesis : There is no difference in microbial community across composition across the BMI classes
-   Alternative hypothesis: There is a difference in microbial community composition across BMI classes.

```{r}
# PERMANOVA to   see whether the diversity of microbial communities differ across bmi
anova_result_bmi <- adonis2(bc_dist ~ BMI_class,
                         data = dataset)
print(anova_result_bmi)
```

The results of the PERMANOVA agree with what is seen in the PCoA as the P.value is 0.208, which indicates that the differences in microbial composition across BMI classes is not significant. Also R2=0.0238 means that bmi contributes to only 2.38% of the variance in the diversity of microbial community across the bmi classes.

### Statistical analysis of samples microbiota

Before we can study how the bacterial species may be related to type 2 diabetes, we need to find which bacteria have more than 50 values that are not 0. Even though 0 is a meaningful value in the dataset, we need some data points to vary in order to see if there is a meaning full relationship.

```{r}
#Get a list of the bacteria that have less than n samples where the value is different from 0
n <- 50
sparse_columns <- dataset |>  
  select(starts_with("s_")) |> 
  pivot_longer(cols = starts_with("s_"),
               names_to = "bacteria",
               values_to = "abundance") |> 
  filter(abundance > -2.5) |> 
  group_by(bacteria) |> 
  summarise(non_zero_samples = n()) |> 
  filter(non_zero_samples < n) |> 
  pull(bacteria)
```

```{r}
#splitting dataset into metadata and bacteria data 
metadata <- dataset |> 
  select(-starts_with("s_")) 
```

We will perform the p-value analysis where we compare the bacterial samples from normal and T2D (type 2 diabetes) patients. Therefore, we will remove the impaired samples and sparse data. Next, we will transform the columns and convert the data from wide format to long format to conduct the p-value analysis.

```{r}
dataset_long <- dataset |> 
  filter(glucose_tolerance != "impaired" ) |> 
  select(-all_of(sparse_columns)) |> 
  pivot_longer(cols = starts_with("s_"),
               names_to = "bacteria",
               values_to = "abundance")
```

Then we group the data by bacteria and nest it. After that, we ungroup it. By doing so, we obtain another tibble, which is a table for each bacterium.

```{r}
dataset_long_nested <- dataset_long|> 
  group_by(bacteria) |> 
  nest() |> 
  ungroup()

dataset_long_nested
```

Here we see how the data can be pulled out for a choosen bacterium.

```{r}
#How to get the data
dataset_long_nested |> 
  filter(bacteria == "s_Bacteroides_caccae") |> 
  pull(data)
```

Then we fit a linear fitting model to each bacterium.

```{r}
dataset_long_nested <- dataset_long_nested |> 
  group_by(bacteria) |> 
  mutate(model_object = map(.x = data,
                            .f = ~lm(formula = abundance ~ is_diseased,
                                     data = .x))) |> 
  mutate(model_object_tidy = map(.x = model_object,
                                 .f = ~tidy(x = .x,
                                            conf.int = TRUE,
                                            conf.level = 0.95)))
```

Then we show how a linear model for a random bacterium would look.

```{r}
#How to get the model
dataset_long_nested |> 
  filter(bacteria == "s_Bacteroides_caccae") |> 
  pull(model_object_tidy)
```

We unnest the model object so we can access the data and values inside the model.

```{r}
dataset_estimates <- dataset_long_nested |> 
  unnest(model_object_tidy)
dataset_estimates
```

Then we check if there are any bacteria that are significant at the alpha = 0.05 level. We filter for those, and we find that none of the bacteria are significant at that level.

```{r}
dataset_estimates <- dataset_estimates |> 
  filter(term == "is_diseased") |> 
  select(bacteria,p.value,estimate,conf.low,conf.high,p.value) |> 
  ungroup() |> 
  mutate(q.value = p.adjust(p.value),
         is_significant = case_when(q.value <= 0.05 ~ "yes",
                                    q.value > 0.05 ~ "no"))

significant_species <- dataset_estimates |> 
  filter(is_significant == "yes")
```

```{r}
sig_diff_species <- significant_species |> 
ggplot(aes(x = estimate,
             y = bacteria,
             xmin = conf.low,
             xmax = conf.high)) +
  geom_vline(xintercept = 0) +
  geom_errorbarh() +
  geom_point() +
  theme_minimal(base_size = 12) +
  theme(plot.title = element_text(hjust = 1)) +
  labs(x = "Estimated difference  (95% CIs)",
       y = expression("Different abundant species"))

save_plot_custom(
  plot = sig_diff_species,
  filename = "10_sig_diff_species.jpg"
)
sig_diff_species
```

```{r}
# clean environment
# rm(list = ls() |>  
#       keep(~ !is.function(get(.))) |>  
#       discard(~ . %in% ls()))
```


```{r}
# List of .qmd files
quarto_files <- c("01_download.qmd", "02_load.qmd", "03_data_selection.qmd", 
           "04_clean.qmd", "05_tidy.qmd", "06_augment.qmd", 
           "07_describe_metadata.qmd", "08_describe_abundance.qmd", 
           "09_analysis_metadata.qmd", "10_analysis_abundance.qmd")

# Render all quarto files in their own html
quarto_files |> 
  walk(~ quarto_render(.x, execute = TRUE, output_format = "html"))
```

```{r}
# Move the rendered html to the results folder
html_files <- list.files(path = getwd(), pattern = "\\.html$", full.names = TRUE)
file.rename(html_files, file.path("../results/", basename(html_files)))

# removed unwanted folder created as byproduct of rendereing all the documents
unlink("*_files", recursive = TRUE)
```

